#!/usr/bin/env node
/**
 * Database Schema to Code Generator
 * 
 * This tool:
 * 1. Queries a PostgreSQL table schema
 * 2. Generates backend model (BaseModel class)
 * 3. Generates frontend schema (defineEntitySchema)
 * 4. Outputs to text files for review
 * 
 * Usage (from project root): node scripts/schema-generator.js <table_name>
 * Example: node scripts/schema-generator.js meter
 * 
 * Or from client/backend: node ../../scripts/schema-generator.js meter
 */

// Try to load from client/backend first, then fallback to root
try {
    require('dotenv').config({ path: require('path').join(__dirname, '../client/backend/.env') });
} catch (e) {
    require('dotenv').config();
}

// Try to require pg from client/backend node_modules
let Pool;
try {
    Pool = require('../client/backend/node_modules/pg').Pool;
} catch (e) {
    try {
        Pool = require('pg').Pool;
    } catch (e2) {
        console.error('‚ùå Error: pg module not found. Please run: cd client/backend && npm install');
        process.exit(1);
    }
}
const fs = require('fs');
const path = require('path');

// Database connection
const pool = new Pool({
    host: process.env.POSTGRES_HOST,
    port: parseInt(process.env.POSTGRES_PORT || '5432', 10),
    database: process.env.POSTGRES_DB,
    user: process.env.POSTGRES_USER,
    password: process.env.POSTGRES_PASSWORD
});

// Type mapping from PostgreSQL to JavaScript/TypeScript
const PG_TO_JS_TYPE = {
    'integer': 'number',
    'bigint': 'number',
    'smallint': 'number',
    'numeric': 'number',
    'real': 'number',
    'double precision': 'number',
    'serial': 'number',
    'bigserial': 'number',
    'character varying': 'string',
    'varchar': 'string',
    'character': 'string',
    'char': 'string',
    'text': 'string',
    'boolean': 'boolean',
    'date': 'date',
    'timestamp without time zone': 'date',
    'timestamp with time zone': 'date',
    'time': 'string',
    'json': 'object',
    'jsonb': 'object',
    'uuid': 'string',
    'inet': 'string',
    'cidr': 'string',
    'macaddr': 'string'
};

// Convert snake_case to camelCase
function toCamelCase(str) {
    return str.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
}

// Convert snake_case to PascalCase
function toPascalCase(str) {
    const camel = toCamelCase(str);
    return camel.charAt(0).toUpperCase() + camel.slice(1);
}

// Convert column name to label
function toLabel(str) {
    return str
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}

// Query table schema
async function queryTableSchema(tableName) {
    try {
        const result = await pool.query(`
            SELECT 
                c.column_name,
                c.data_type,
                c.character_maximum_length,
                c.is_nullable,
                c.column_default,
                c.udt_name,
                pgd.description
            FROM information_schema.columns c
            LEFT JOIN pg_catalog.pg_statio_all_tables st 
                ON c.table_schema = st.schemaname 
                AND c.table_name = st.relname
            LEFT JOIN pg_catalog.pg_description pgd 
                ON pgd.objoid = st.relid 
                AND pgd.objsubid = c.ordinal_position
            WHERE c.table_name = $1
            ORDER BY c.ordinal_position;
        `, [tableName]);

        if (result.rows.length === 0) {
            throw new Error(`Table '${tableName}' not found in database`);
        }

        return result.rows;
    } catch (error) {
        throw new Error(`Failed to query schema: ${error.message}`);
    }
}

// Generate backend model class
function generateBackendModel(tableName, columns) {
    const className = toPascalCase(tableName);
    const varName = toCamelCase(tableName);
    
    let code = `// @ts-nocheck
/**
 * ${className} Model for PostgreSQL
 * Extends BaseModel for automatic CRUD generation
 * 
 * Generated from database schema
 */

const BaseModel = require('../../../../framework/backend/api/base/BaseModel');
const db = require('../config/database');

class ${className} extends BaseModel {
  constructor(${varName}Data = {}) {
    super(${varName}Data);
    
    // Field definitions only - CRUD methods are generated by BaseModel
`;

    // Add field assignments
    columns.forEach(col => {
        const fieldName = col.column_name;
        const comment = col.description ? ` // ${col.description}` : '';
        
        if (col.column_default && col.column_default.includes('nextval')) {
            // Auto-increment field
            code += `    this.${fieldName} = ${varName}Data.${fieldName};${comment}\n`;
        } else if (col.column_default) {
            // Has default value
            const defaultVal = col.column_default.replace(/::.*$/, '').replace(/'/g, '');
            code += `    this.${fieldName} = ${varName}Data.${fieldName};${comment}\n`;
        } else {
            code += `    this.${fieldName} = ${varName}Data.${fieldName};${comment}\n`;
        }
    });

    code += `  }

  // ===== Static Configuration =====
  
  /**
   * Database table name
   */
  static get tableName() {
    return '${tableName}';
  }

  /**
   * Primary key field
   */
  static get primaryKey() {
    return 'id';
  }

  /**
   * Relationship definitions
   * TODO: Add relationships based on foreign keys
   */
  static get relationships() {
    return {
      // Example:
      // parentTable: {
      //   type: 'belongsTo',
      //   model: 'ParentModel',
      //   foreignKey: 'parent_id',
      //   targetKey: 'id'
      // }
    };
  }

  // ===== Custom Methods =====

  /**
   * Get ${tableName} statistics
   */
  static async getStats() {
    const query = \`
      SELECT
        COUNT(*) as total_count
      FROM ${tableName}
    \`;

    const result = await db.query(query);
    return result.rows[0];
  }

  /**
   * Convert to JSON
   */
  toJSON() {
    return {
      ...this
    };
  }
}

module.exports = ${className};
`;

    return code;
}

// Generate frontend schema
function generateFrontendSchema(tableName, columns) {
    const className = toPascalCase(tableName);
    const varName = toCamelCase(tableName);
    
    // Separate form fields from entity fields
    const formFields = [];
    const entityFields = [];
    const readOnlyFields = ['id', 'created_at', 'updated_at', 'created_by', 'updated_by'];
    
    columns.forEach(col => {
        const fieldName = toCamelCase(col.column_name);
        const jsType = PG_TO_JS_TYPE[col.data_type] || 'string';
        const isRequired = col.is_nullable === 'NO' && !col.column_default;
        const isReadOnly = readOnlyFields.includes(col.column_name);
        
        if (isReadOnly) {
            entityFields.push({ name: fieldName, type: jsType, col });
        } else {
            formFields.push({ name: fieldName, type: jsType, required: isRequired, col });
        }
    });

    let code = `/**
 * ${className} Configuration
 * 
 * Centralized configuration for ${className} entity including:
 * - Form schema (field definitions, validation, API mapping)
 * - List columns, filters, stats
 * - Bulk actions and export configuration
 * 
 * Generated from database schema
 */

import React from 'react';
import type { ColumnDefinition } from '../../types/ui';
import type { FilterDefinition, BulkActionConfig, ExportConfig } from '@framework/lists/types/list';
import { Permission } from '../../types/auth';
import { field } from '@framework/forms/utils/formSchema';
import { defineEntitySchema } from '@framework/forms/utils/entitySchema';
import {
  createStatusColumn,
  createStandardStatusActions,
  createExportAction,
} from '../../config/listHelpers';

// ============================================================================
// UNIFIED SCHEMA DEFINITION
// ============================================================================

/**
 * ${className} entity schema - single source of truth for ${className} entity
 * Defines form fields, entity fields, and legacy field mappings
 */
export const ${varName}Schema = defineEntitySchema({
  formFields: {
`;

    // Add form fields
    formFields.forEach((field, idx) => {
        const defaultValue = field.type === 'number' ? '0' : 
                           field.type === 'boolean' ? 'false' : 
                           field.type === 'date' ? 'new Date()' : "''";
        const label = toLabel(field.col.column_name);
        
        code += `    ${field.name}: field({ type: '${field.type}', default: ${defaultValue}, ${field.required ? 'required: true, ' : ''}label: '${label}' })${idx < formFields.length - 1 ? ',' : ''}\n`;
    });

    code += `  },
  
  entityFields: {
`;

    // Add entity fields (read-only)
    entityFields.forEach((field, idx) => {
        const defaultValue = field.type === 'number' ? '0' : 
                           field.type === 'boolean' ? 'false' : 
                           field.type === 'date' ? 'new Date()' : "''";
        
        code += `    ${field.name}: { type: '${field.type}' as const, default: ${defaultValue}, readOnly: true }${idx < entityFields.length - 1 ? ',' : ''}\n`;
    });

    code += `  },
  
  entityName: '${className}',
  description: '${className} entity for managing ${tableName} records',
} as const);

/**
 * ${className} form schema - exported for backward compatibility
 * Used by ${className}Form component
 */
export const ${varName}FormSchema = ${varName}Schema.form;

/**
 * ${className} TypeScript type - inferred from schema
 */
export type ${className} = typeof ${varName}Schema._entityType & {
`;

    // Add all fields to type
    columns.forEach(col => {
        const fieldName = toCamelCase(col.column_name);
        const jsType = PG_TO_JS_TYPE[col.data_type] || 'string';
        const isNullable = col.is_nullable === 'YES';
        
        code += `  ${fieldName}${isNullable ? '?' : ''}: ${jsType};\n`;
    });

    code += `};

/**
 * Create ${varName} request type for form submission
 */
export interface Create${className}Request {
`;

    // Add form fields to request type
    formFields.forEach(field => {
        code += `  ${field.name}${field.required ? '' : '?'}: ${field.type};\n`;
    });

    code += `}

/**
 * Update ${varName} request type
 */
export interface Update${className}Request extends Partial<Create${className}Request> {
  id?: string;
}

// ============================================================================
// LIST CONFIGURATION
// ============================================================================

/**
 * Column definitions for ${varName} list
 */
export const ${varName}Columns: ColumnDefinition<${className}>[] = [
  // TODO: Customize columns based on your needs
  {
    key: 'id' as keyof ${className},
    label: 'ID',
    sortable: true,
  },
`;

    // Add first few non-id columns as examples
    const displayColumns = formFields.slice(0, 3);
    displayColumns.forEach(field => {
        code += `  {
    key: '${field.name}' as keyof ${className},
    label: '${toLabel(field.col.column_name)}',
    sortable: true,
  },
`;
    });

    code += `];

/**
 * Filter definitions for ${varName} list
 */
export const ${varName}Filters: FilterDefinition[] = [
  // TODO: Add filters based on your needs
];

/**
 * Export configuration for ${varName} list
 */
export const ${varName}ExportConfig: ExportConfig<${className}> = {
  filename: (date: string) => \`${tableName}_export_\${date}.csv\`,
  headers: [
`;

    // Add headers for export
    columns.forEach((col, idx) => {
        code += `    '${toLabel(col.column_name)}'${idx < columns.length - 1 ? ',' : ''}\n`;
    });

    code += `  ],
  mapRow: (${varName}: ${className}) => [
`;

    // Add row mapping
    columns.forEach((col, idx) => {
        const fieldName = toCamelCase(col.column_name);
        const jsType = PG_TO_JS_TYPE[col.data_type] || 'string';
        
        if (jsType === 'date') {
            code += `    ${varName}.${fieldName} ? new Date(${varName}.${fieldName}).toISOString() : ''${idx < columns.length - 1 ? ',' : ''}\n`;
        } else {
            code += `    ${varName}.${fieldName} || ''${idx < columns.length - 1 ? ',' : ''}\n`;
        }
    });

    code += `  ],
  includeInfo: '${className} export with full details',
};
`;

    return code;
}

// Main function
async function main() {
    const tableName = process.argv[2];
    
    if (!tableName) {
        console.error('Usage: node scripts/schema-generator.js <table_name>');
        console.error('Example: node scripts/schema-generator.js meter');
        process.exit(1);
    }

    console.log(`\nüîç Querying schema for table: ${tableName}\n`);

    try {
        // Query schema
        const columns = await queryTableSchema(tableName);
        
        console.log(`‚úÖ Found ${columns.length} columns\n`);
        
        // Display schema
        console.log('=== TABLE SCHEMA ===\n');
        columns.forEach(col => {
            const type = col.data_type + (col.character_maximum_length ? `(${col.character_maximum_length})` : '');
            const nullable = col.is_nullable === 'YES' ? 'NULL' : 'NOT NULL';
            const defaultVal = col.column_default ? ` DEFAULT ${col.column_default}` : '';
            console.log(`  ${col.column_name}: ${type} ${nullable}${defaultVal}`);
        });
        console.log('\n====================\n');

        // Generate backend model
        console.log('üìù Generating backend model...');
        const backendCode = generateBackendModel(tableName, columns);
        const backendPath = path.join(__dirname, '..', 'generated', `${toPascalCase(tableName)}.js`);
        fs.mkdirSync(path.dirname(backendPath), { recursive: true });
        fs.writeFileSync(backendPath, backendCode);
        console.log(`‚úÖ Backend model saved to: ${backendPath}\n`);

        // Generate frontend schema
        console.log('üìù Generating frontend schema...');
        const frontendCode = generateFrontendSchema(tableName, columns);
        const frontendPath = path.join(__dirname, '..', 'generated', `${toCamelCase(tableName)}Config.ts`);
        fs.writeFileSync(frontendPath, frontendCode);
        console.log(`‚úÖ Frontend schema saved to: ${frontendPath}\n`);

        // Generate summary
        const summaryPath = path.join(__dirname, '..', 'generated', `${tableName}_schema_summary.txt`);
        const summary = `
DATABASE SCHEMA TO CODE GENERATION SUMMARY
==========================================

Table: ${tableName}
Generated: ${new Date().toISOString()}
Columns: ${columns.length}

FILES GENERATED:
1. Backend Model: ${backendPath}
2. Frontend Schema: ${frontendPath}

NEXT STEPS:
1. Review the generated files
2. Copy backend model to: client/backend/src/models/${toPascalCase(tableName)}.js
3. Copy frontend schema to: client/frontend/src/features/${tableName}s/${toCamelCase(tableName)}Config.ts
4. Update relationships in backend model
5. Customize frontend columns, filters, and validation
6. Update form components to use the new schema

COLUMNS:
${columns.map(col => `  - ${col.column_name} (${col.data_type})`).join('\n')}
`;
        fs.writeFileSync(summaryPath, summary);
        console.log(`üìÑ Summary saved to: ${summaryPath}\n`);

        console.log('‚ú® Generation complete!\n');
        
    } catch (error) {
        console.error(`‚ùå Error: ${error.message}`);
        process.exit(1);
    } finally {
        await pool.end();
    }
}

// Run
main();
